# RoomとCoroutines
## コルーチンとは
コルーチンは長時間実行されるタスクをエレガントかつ効率的に処理する方法です。
Kotlinコルーチンを使用すると、コールバックベースのコードをシーケンシャルコードに変換できます。順次記述されたコードは、通常、読みやすく、例外などの言語機能を使用することもできる(シーケンシャルコードはシーケンスと同じで、並んでいる順番に処理すること)。
結局、コルーチンとコールバックは同じことを行います。つまり、実行時間の長いタスクから結果が得られるまで待機し、実行を続行する。いわゆる非同期。
コルーチンは非ブロッキング。
サスペンド関数を使うと非同期コードをシーケンシャルにする。

コルーチンには3つが必要
- Job
  - 全てのコルーチンにはジョブがあり、キャンセルもできる。親ジョブと子ジョブのように配置ができて、親ジョブをキャンセルすると必然的に子ジョブもキャンセルされる。
- Dispatcher
  - 様々なスレッドで実行するSteoを送信する。例えば、メインスレッドでタスクを実行する時は`Dispatcher.Main`になり、`Dispatcher.IO`はI/Oブロッキングタスクをスレッド共有プールにオフロードする。(ちょっとわかんない)
- Scope
  - コルーチンが実行されるコンテキストを定義する。スコープはSteoのジョブとディスパッチャーに関する情報を組み合わせたもの。

Roomライブラリを使用してデータベース操作を実行する場合、Roomは`Dispatcher.IO`を利用してバックグラウンドでデータベース操作を実行します。Dispatcherを明示的に指定する必要はありません。


# まとめ
- ViewModel,ViewModelFactory,UIアーキテクチャを設定するデータバインディングで使用する。
- UIをスムーズに実行し続けるには、実行時間の長いタスクにコルーチンを使う。
- コルーチンは非同期で非ブロッキング。susoend関数を使って、非同期コードをシーケンシャルにする。
- コルーチンがsuspendでマークした関数を呼び出すと、関数が通常の関数の呼び出しのように返ってくるまでブロッキングするのではなく、結果の準備ができるまで実行を一時停止する。
次に、中断したところから再開して結果を出力する。
- ブロックと一時停止の違いは、スレッドがブロックされた場合は、他の処理は動かないことである。スレッドが中断された場合は結果が準備できるまで、他の処理を行うことができる。

データベース操作をトリガーするクリックハンドラーを実装するには、
1. 結果がUIに影響するため、メインスレッドまたは、UIスレッドでコルーチンを起動する
2. 一時停止関数を呼び出して長時間処理される作業を実行し、結果を待っている間、UIスレッドをブロックしないようにする。
3. 長時間実行される作業はUIと関係がないので、I/Oコンテキストに切り替える。そうすれば、これらの操作のために最適化されてスレッドプールで処理を実行できる。
4. 最後に長時間実行されている関数を呼び出して作業を行う。

オブジェクトが変更されるたびに、Transformations.mapを使ってLiveDataオブジェクトから文字列を生成するようにする。


# その他
- レイアウトの<merge>タグを使って実装していくことでビュー階層が簡素化される
  - navigation.xmlを使う
