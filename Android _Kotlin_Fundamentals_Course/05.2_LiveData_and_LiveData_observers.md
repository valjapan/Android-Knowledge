# LiveDataとは

- ライフサイクルを意識した監視可能なデータホルダークラス
- LiveDataは監視をする役割がある。つまりLiveDataオブジェクトが保持するデータに変更が入ると、監視しているLiveDataに通知が行く
- LiveDataはライフサイクルを認識する。オブザーバーにアタッチするLiveDataと、オブザーバーはLifecycleOwner(普段はアクティビティやフラグメント)に関連付けされる。


## なぜViewLifecycleOwnerを使うのか？
フラグメント自体が破棄されていなくても、ユーザーがフラグメントから移動すると、フラグメントビューは破棄される。これにより、基本的に、フラグメントのライフサイクルとフラグメントのビューのライフサイクルの2つのライフサイクルが作成されることになる。
フラグメントビューのライフサイクルではなくフラグメントのライフサイクルを参照すると、フラグメントのビューを更新するときに微妙なバグが発生する可能性があります。したがって、フラグメントのビューに影響を与えるオブザーバーを設定するときは、次のことを行う必要があります。

1. onCreateView()でオブザーバーを設定
2. viewLifecycleOwnerオブザーバーに渡す

## LiveDataをカプセル化
カプセル化とは、オブジェクトの一部のフィールドへのアクセスを制限する方法。
オブジェクトをカプセル化する時は、プライベート内部フィールドを変更する一連のパブリックメソッドを公開する。
カプセル化を使用して、他のクラスがこれらの内部フィールドを操作する方法を制御します。

アプリのデータをカプセル化するには、MutableLiveDataとLiveDataオブジェクトの両方を使用する。
### MutableLiveData vs LiveData
- MutableLiveData名前が示すように、オブジェクト内のデータは変更できる。ViewModelの内部では、データは編集可能である必要があるため、MutableLiveDataを使用する。
- LiveDataオブジェクト内のデータは読み取ることができるが、変更することはできない。ViewModelの外部から、データは読み取り可能である必要があるが、編集可能ではないため、データはLiveDataとして公開する必要があります。

MutableLiveData = 編集可能
LiveData = 読み取り可能

この戦略を実行するには、Kotlinバッキングプロパティを使用する。
要するに、ViewModelにどちらも用意し、_scoreは編集可能(他フラグメントとかから値の更新が入る)にさせ、scoreでは結果を表示させる(読み取りのみ)ので、_scoreに入っている値を持って表示する仕組みである。

``` .kt
private val _score = MutableLiveData<Int>()
val score: LiveData<Int>
    get() = _score
```


## LiveDataを監視する
- LiveDataオブザーバーパターンに従います。「オブザーバブル」はLiveDataオブジェクトであり、オブザーバーはフラグメントのようなUIコントローラーのメソッドです。内部にラップされたデータがLiveData変更されるたびに、UIコントローラーのオブザーバーメソッドに通知されます。
- LiveDataオブザーバブルを作成するにはLiveData.observe()メソッドを使用してオブザーバーオブジェクト（アクティビティやフラグメントなど）をオブザーバーの参照にアタッチします。
- このLiveDataオブザーバーパターンは、ViewModelからUIコントローラーへの通信に使用できます。
